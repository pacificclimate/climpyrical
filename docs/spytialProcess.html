<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>spytialProcess API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spytialProcess</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import OrderedDict
from pkg_resources import resource_string

from nptyping import NDArray
from typing import Any, Tuple
import numpy as np
from rpy2.robjects.packages import importr
from rpy2.robjects import FloatVector, DataFrame
from rpy2 import robjects

import rpy2.robjects.packages as rpackages

# from rpy2.robjects.vectors import StrVector

utils = rpackages.importr(&#34;utils&#34;)
utils.install_packages(&#34;fields&#34;, version=&#34;11.3&#34;)


# utils.chooseCRANmirror(ind=1) # select the first mirror in the list

# utils.install_packages(StrVector((&#34;fields&#34;)), &#34;../r-library&#34;)
# utils.install_packages(StrVector((&#34;sp&#34;)), &#34;../r-library&#34;)
# utils.install_packages(StrVector((&#34;gstat&#34;)), &#34;../r-library&#34;)

# print(&#34;FIELDS&#34;)
importr(&#34;fields&#34;)
# importr(&#34;sp&#34;)
# importr(&#34;gstat&#34;)


def fit(
    latlon: NDArray[(2, Any), float],
    z: NDArray[(Any,), float],
    nx: int,
    ny: int,
    extrap: bool,
) -&gt; Tuple[
    NDArray[(Any, Any), float], NDArray[(Any,), float], NDArray[(Any,), float]
]:

    &#34;&#34;&#34;Encapsulates the functionality of R&#39;s spatialProcess into a Python
    Args:
        latlon: grid of pairwise coordinates of observations
        z: observations
        nx: number of grid cells on interpolated grid x
        nx: number of grid cells on interpolated grid y
        xy: dimensions of interpolated grid output
        distance: distance metric to use (note, only &#39;geo&#39; supported currently)
        variogram_model: choice of variogram model
          (note, only &#39;exoponential&#39; supported)
    Returns:
        z: kriged field
        x, y: locations of kriged data

    &#34;&#34;&#34;

    if not isinstance(latlon, NDArray[(2, Any), float]):
        raise TypeError(
            f&#34;Incorrect grid shape, size, or dtype. Must be {NDArray[(2, Any), float]}&#34;
        )

    if not isinstance(z, NDArray[(Any,), float]):
        raise TypeError(
            f&#34;Incorrect grid shape, size, or dtype. Must be {NDArray[(Any, ), float]}&#34;
        )

    if not isinstance(nx, int) or not isinstance(ny, int):
        raise TypeError(&#34;Provide integer grid size&#34;)

    if latlon.shape[1] != z.size:
        raise ValueError(
            &#34;Different number of grid coordinates than observations&#34;
        )

    latlon, z = latlon.tolist(), z.tolist()

    # convert regular numeric data

    # convert latlon list into two R FloatVectors
    # list of FloatVector -&gt; OrderedDict -&gt; R DataFrame
    # -&gt; numeric R data matrix
    r_lists = list(map(FloatVector, latlon))
    coords = OrderedDict(zip(map(str, range(len(r_lists))), r_lists))
    r_dataFrame = DataFrame(coords)
    r_latlon = robjects.r[&#34;data.matrix&#34;](r_dataFrame)

    # convert observations
    r_z = FloatVector(z)

    # use separate simple r-script in path below
    rstring = resource_string(
        &#34;climpyrical&#34;, &#34;tests/data/spatial_process_r.R&#34;
    ).decode(&#34;utf-8&#34;)

    rfunc = robjects.r(rstring)
    r_surface = rfunc(r_latlon, r_z, nx, ny, extrap)

    # extract data from R&#39;s interpolation
    surface_dict = dict(zip(r_surface.names, list(r_surface)))
    # z = np.array(list(r_surface[1]))
    z = np.array(surface_dict[&#34;z&#34;]).reshape(nx, ny)
    x = np.array(surface_dict[&#34;x&#34;])
    y = np.array(surface_dict[&#34;y&#34;])
    # cov = dict(zip(surface_dict[&#34;cov&#34;].names, list(surface_dict[&#34;cov&#34;])))
    # cov = surface_dict[&#34;cov&#34;]

    return z, x, y</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spytialProcess.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>latlon: nptyping.types._ndarray.NDArray, z: nptyping.types._ndarray.NDArray, nx: int, ny: int, extrap: bool) ‑> Tuple[nptypes._ndarray.NDArray, nptypes._ndarray.NDArray, nptypes._ndarray.NDArray]</span>
</code></dt>
<dd>
<div class="desc"><p>Encapsulates the functionality of R's spatialProcess into a Python</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>latlon</code></strong></dt>
<dd>grid of pairwise coordinates of observations</dd>
<dt><strong><code>z</code></strong></dt>
<dd>observations</dd>
<dt><strong><code>nx</code></strong></dt>
<dd>number of grid cells on interpolated grid x</dd>
<dt><strong><code>nx</code></strong></dt>
<dd>number of grid cells on interpolated grid y</dd>
<dt><strong><code>xy</code></strong></dt>
<dd>dimensions of interpolated grid output</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>distance metric to use (note, only 'geo' supported currently)</dd>
<dt><strong><code>variogram_model</code></strong></dt>
<dd>choice of variogram model
(note, only 'exoponential' supported)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>z</code></dt>
<dd>kriged field</dd>
<dt><code>x, y</code></dt>
<dd>locations of kriged data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
    latlon: NDArray[(2, Any), float],
    z: NDArray[(Any,), float],
    nx: int,
    ny: int,
    extrap: bool,
) -&gt; Tuple[
    NDArray[(Any, Any), float], NDArray[(Any,), float], NDArray[(Any,), float]
]:

    &#34;&#34;&#34;Encapsulates the functionality of R&#39;s spatialProcess into a Python
    Args:
        latlon: grid of pairwise coordinates of observations
        z: observations
        nx: number of grid cells on interpolated grid x
        nx: number of grid cells on interpolated grid y
        xy: dimensions of interpolated grid output
        distance: distance metric to use (note, only &#39;geo&#39; supported currently)
        variogram_model: choice of variogram model
          (note, only &#39;exoponential&#39; supported)
    Returns:
        z: kriged field
        x, y: locations of kriged data

    &#34;&#34;&#34;

    if not isinstance(latlon, NDArray[(2, Any), float]):
        raise TypeError(
            f&#34;Incorrect grid shape, size, or dtype. Must be {NDArray[(2, Any), float]}&#34;
        )

    if not isinstance(z, NDArray[(Any,), float]):
        raise TypeError(
            f&#34;Incorrect grid shape, size, or dtype. Must be {NDArray[(Any, ), float]}&#34;
        )

    if not isinstance(nx, int) or not isinstance(ny, int):
        raise TypeError(&#34;Provide integer grid size&#34;)

    if latlon.shape[1] != z.size:
        raise ValueError(
            &#34;Different number of grid coordinates than observations&#34;
        )

    latlon, z = latlon.tolist(), z.tolist()

    # convert regular numeric data

    # convert latlon list into two R FloatVectors
    # list of FloatVector -&gt; OrderedDict -&gt; R DataFrame
    # -&gt; numeric R data matrix
    r_lists = list(map(FloatVector, latlon))
    coords = OrderedDict(zip(map(str, range(len(r_lists))), r_lists))
    r_dataFrame = DataFrame(coords)
    r_latlon = robjects.r[&#34;data.matrix&#34;](r_dataFrame)

    # convert observations
    r_z = FloatVector(z)

    # use separate simple r-script in path below
    rstring = resource_string(
        &#34;climpyrical&#34;, &#34;tests/data/spatial_process_r.R&#34;
    ).decode(&#34;utf-8&#34;)

    rfunc = robjects.r(rstring)
    r_surface = rfunc(r_latlon, r_z, nx, ny, extrap)

    # extract data from R&#39;s interpolation
    surface_dict = dict(zip(r_surface.names, list(r_surface)))
    # z = np.array(list(r_surface[1]))
    z = np.array(surface_dict[&#34;z&#34;]).reshape(nx, ny)
    x = np.array(surface_dict[&#34;x&#34;])
    y = np.array(surface_dict[&#34;y&#34;])
    # cov = dict(zip(surface_dict[&#34;cov&#34;].names, list(surface_dict[&#34;cov&#34;])))
    # cov = surface_dict[&#34;cov&#34;]

    return z, x, y</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spytialProcess.fit" href="#spytialProcess.fit">fit</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>